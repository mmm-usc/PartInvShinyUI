---
title: "Evaluating the impact of measurement bias on classification accuracy across multiple groups"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Evaluating the impact of measurement bias on classification accuracy across multiple groups}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Building on Millsap and Kwok's (2004) work on selection accuracy analysis and 
Lai and Zhang's (2022) work on multidimensional classification accuracy analysis
(MCAA), the multi-group MCAA framework allows users to investigate the impact of
item-level measurement bias on classification accuracy indices True Positive 
(TP), False Positive (FP), True Negative (TN), False Negative (FN), Proportion
Selected (PS), Success Ratio (SR), Sensitivity (SE), Specificity (SP) computed 
for multidimensional tests administered to multiple groups.

We first demonstrate the use of `PartInv` for comparison across two groups, and 
follow by a demonstration of the use of `PartInv` for multiple groups.

# PartInv for 2 groups

Assume that we are interested in the classification accuracy of a psychological
test across two groups, Group 1 and Group 2, and we have the unstandardized
parameter estimates from CFA. 



```{r}
#| include: false
library(unbiasr)
library(lavaan)
```

```{r}
# should weights be automatically computed to allocate more weight based on the 
# number of items in the scale?
lambda_matrix <- matrix(0, nrow = 5, ncol = 2)
lambda_matrix[1:2, 1] <- c(.322, .655)
lambda_matrix[3:5, 2] <- c(.398, .745, .543)
PartInv(propsel = .05,
        weights_latent = c(0.5, 0.5),
        alpha = list(c(0, 0), c(-0.3, 0.1)),
        psi = list(matrix(c(1, 0.5, 0.5, 1), nrow = 2),
                   matrix(c(1, 0.5, 0.5, 1), nrow = 2)),
        lambda = list(lambda_matrix, lambda_matrix),
        nu = list(c(.225, .025, .010, .240, .125), 
                  c(.225, -.05, .240, -.025, .125)),
        Theta = list(diag(1, 5), c(1, .95, .80, .75, 1)),
        show_mi_result = TRUE)
```



# PartInv for multiple groups

```{r}
# read and format data
tmp_path <- tempfile(fileext = "xlsx")  # temporary file
download.file("https://osf.io/download/ybvhx/", destfile = tmp_path)
rr <- readxl::read_xlsx(tmp_path, skip = 1)
dat <- sjmisc::rec(rr, Age, append = TRUE, suffix = "_gr",
                    rec = "18:25=1; 26:35=2; 36:45=3; 46:55=4; 
                           56:65=5; 66:75=6; 76:94=7")
dat <- dat[,c(1:22,24)]
colnames(dat) <- c("Gender", paste0("i", 1:20), "Age", "Age_gr")
dat9 <- dat[!(is.na(dat$i1)) & !(is.na(dat$i2)) & !(is.na(dat$i5)) & 
             !(is.na(dat$i6)) & !(is.na(dat$i10)) & !(is.na(dat$i11))
           & !(is.na(dat$i14)) & !(is.na(dat$i19)) & !(is.na(dat$i20)) 
           & !is.na(dat$Age) & !is.na(dat$Age_gr), 
           c(paste0("i", c(2, 11, 14, 19, 20, 10, 1, 6, 5)), 
             "Age_gr")]
colnames(dat9) <- c("i1", "i4", "i8", "i3", "i5", "i7", "i2",
                    "i6", "i9", "Age_gr")
```


```{r}
partial_model <- '
   F1 =~ 
   c(lambda1_1, lambda1, lambda1, lambda1, lambda1, lambda1, lambda1) * i1 + 
   c(lambda4, lambda4, lambda4, lambda4, lambda4, lambda4, lambda4) * i4 + 
   c(lambda8, lambda8, lambda8, lambda8, lambda8, lambda8, lambda8) * i8
   F2 =~ 
   c(lambda3, lambda3, lambda3, lambda3, lambda3_5, lambda3, lambda3) * i3 + 
   c(lambda5, lambda5, lambda5, lambda5, lambda5, lambda5, lambda5) * i5 +
   c(lambda7, lambda7, lambda7_3, lambda7, lambda7, lambda7, lambda7) * i7
   F3 =~
   c(lambda2_1, lambda2, lambda2, lambda2, lambda2, lambda2, lambda2) * i2 + 
   c(lambda6, lambda6, lambda6, lambda6, lambda6, lambda6, lambda6) * i6 + 
   c(lambda9, lambda9, lambda9, lambda9, lambda9, lambda9, lambda9) * i9
   i1 ~~ c(theta1_1, theta1_2, theta1, theta1_4, theta1, theta1, theta1) * i1
   i4 ~~ c(theta4, theta4, theta4, theta4, theta4, theta4, theta4_7) * i4
   i8 ~~ c(theta8, theta8, theta8_3, theta8, theta8, theta8, theta8) * i8
   i3 ~~ c(theta3, theta3, theta3, theta3, theta3, theta3_6, theta3_7) * i3
   i5 ~~ c(theta5_1, theta5, theta5, theta5, theta5, theta5, theta5_7) * i5
   i7 ~~ c(theta7_1, theta7, theta7, theta7, theta7, theta7_6, theta7_7) * i7
   i2 ~~ c(theta2_1, theta2_2, theta2_3, theta2_4, theta2_5, theta2_6, theta2_7) * i2
   i6 ~~ c(theta6_1, theta6, theta6, theta6, theta6, theta6, theta6) * i6
   i9 ~~ c(theta9_1, theta9_2, theta9, theta9, theta9, theta9_6, theta9) * i9
   F1 ~~ c(1, NA, NA, NA, NA, NA, NA) * F1
   F2 ~~ c(1, NA, NA, NA, NA, NA, NA) * F2
   F3 ~~ c(1, NA,  NA, NA, NA, NA, NA) * F3
   F1 ~~ F2 
   F1 ~~ F3
   F2 ~~ F3
   F1 ~ c(0, NA, NA, NA, NA, NA, NA) * 1
   F2 ~ c(0, NA, NA, NA, NA, NA, NA) * 1
   F3 ~ c(0, NA, NA, NA, NA, NA, NA) * 1
   i1 ~ c(nu1_1, nu1_2, nu1, nu1, nu1_5, nu1_6, nu1_7) * 1
   i4 ~ c(nu4_1, nu4, nu4_3, nu4, nu4_5, nu4, nu4) * 1
   i8 ~ c(nu8, nu8_2, nu8, nu8_4, nu8, nu8, nu8) * 1
   i3 ~ c(nu3, nu3, nu3, nu3, nu3_5, nu3, nu3) * 1
   i5 ~ c(nu5, nu5, nu5_3, nu5, nu5, nu5, nu5) * 1
   i7 ~ c(nu7, nu7, nu7_3, nu7, nu7, nu7, nu7) * 1
   i2 ~ c(nu2_1, nu2_2, nu2_3, nu2, nu2, nu2, nu2_7) * 1
   i6 ~ c(nu6, nu6, nu6, nu6, nu6, nu6, nu6) * 1
   i9 ~ c(nu9, nu9, nu9, nu9, nu9, nu9, nu9) * 1
  '
partial_fit <- lavaan::cfa(partial_model, data = dat9, std.lv = TRUE, group = "Age_gr")
pfit <- format_cfa_partinv(partial_fit)
partinv9 <-
  PartInv(cut_z = 27.81,
          psi = pfit$psi,
          lambda = pfit$lambda,
          Theta = pfit$Theta,
          alpha = pfit$alpha,
          nu = pfit$nu,
          pmix = table(dat9$Age_gr) / dim(dat9)[1],
          plot_contour = TRUE,
          labels = c("Age 1", "Age 2", "Age 3", "Age 4", "Age 5",
                     "Age 6", "Age 7"),
          show_mi_result = TRUE) 
partinv9
```





